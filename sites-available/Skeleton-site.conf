server {
    # Listen on IPv4 and IPv6
    listen 80;
    listen [::]:80;

    # The host name to respond to
    server_name @@SITE_DOMAIN@@;

    # Path for static files
    root /home/@@SITE_USER@@/website/html;

    # Logging
    access_log /home/@@SITE_USER@@/log/@@SITE_USER@@-access.log main;
    error_log  /home/@@SITE_USER@@/log/@@SITE_USER@@-error.log notice;

    # User config / incron
    #include /home/@@SITE_USER@@/website/nginx.conf;
    # Deny access to the nginx.conf file generated by W3T
    #location = /nginx.conf {
    #    deny all;
    #}

    # Specify a charset
    charset utf-8;

    # Index files
    index index.php index.html index.htm;

    # Custom 404 page
    #error_page 404 /404.html;

    include h5bp/basic.conf;
    include h5bp/directive-only/cache-file-descriptors.conf;

    # "nginx first searches for the most specific prefix location
    #  given by literal strings regardless of the listed order"
    location = /favicon.ico {
        access_log off;
        expires 1M;
        add_header Cache-Control "public";
    }
    location = /apple-touch-icon.png {
        access_log off;
        expires 1M;
        add_header Cache-Control "public";
    }
    location = /apple-touch-icon-precomposed.png {
        access_log off;
        expires 1M;
        add_header Cache-Control "public";
    }

    # Allow even for password protected sites
    location = /robots.txt {
        allow all;
        try_files $uri /index.php?$args;
    }

    location / {
        location ~ "sitemap.*\.xml$" {
            try_files $uri $uri/ /index.php?$args;
        }
        location ~ "sitemap.*\.xsl$" {
            try_files $uri $uri/ /index.php?$args;
        }
        # Include the "?$args" part so non-default permalinks doesn't break when using query string
        try_files $uri $uri/ /index.php?$args;
    }

    location ~ "\.php$" {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/run/php5-fpm-@@SITE_USER@@.sock;
        # For 404 and wpf2b
        fastcgi_intercept_errors on;
        # FastCGI cache
        fastcgi_cache @@CACHEZONE@@;
        fastcgi_cache_valid 200 10m;
        fastcgi_cache_bypass $query_string $http_pragma;
        fastcgi_no_cache $query_string $http_pragma;
        add_header X-Nginx-Cache $upstream_cache_status;
    }
}

# REDIRECT
server {
    listen [::]:80;
    listen 80;
    # www -> non-www
    server_name www.@@SITE_DOMAIN@@;
    return 301 $scheme://@@SITE_DOMAIN@@$request_uri;
}
